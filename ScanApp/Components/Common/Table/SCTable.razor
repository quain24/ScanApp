@using ScanApp.Components.Common.ScanAppTable.Options
@using ScanApp.Common.Extensions
@using System.Globalization
@using ScanApp.Common.Helpers
@using ScanApp.Components.Common.Table.Dialogs
@using ScanApp.Components.Common.Table.Utilities
@using SharedExtensions
@inject IDialogService _dialogService
@typeparam TTableType

@if (Configs?.Count > 0 && _groupables.Count > 0)
{
    <MudSelect FullWidth="false" Value="SelectedGroupable" ValueChanged="@(CreateGroupsBasedOn)" T="ColumnConfig<TTableType>" Label="Groups">
        <MudSelectItem T="ColumnConfig<TTableType>" Value="null">None</MudSelectItem>
        @foreach (var cc in _groupables)
        {
            <MudSelectItem Value="cc">@cc.DisplayName</MudSelectItem>
        }
    </MudSelect>
}

@if (GroupedData?.Count > 0)
{
    <MudTable Items="GroupedData" T="KeyValuePair<string, List<TTableType>>" OnRowClick="OnGroupClick"
              FixedHeader="FixedHeader" FixedFooter="FixedFooter" Height="@CalculateHeight()" RowsPerPage="RowsPerPage"
              Class="m-0 p-0" Elevation="0" Bordered="false" Striped="true" Hover="true" Outlined="false" Dense="true" Breakpoint="Breakpoint.None">
        <HeaderContent>
            <MudTh Style="padding: 10px; z-index: 10">
                Grouped by: @SelectedGroupable.DisplayName
            </MudTh>
        </HeaderContent>

        <RowTemplate>
            <MudTd DataLabel="@context.Key">@context.Key</MudTd>
        </RowTemplate>
        <ChildRowContent>
            @if (_selectedGroupId == context.Key)
            {
                <MudTable Items="@FilterDataSource(context.Value)" T="TTableType" @bind-SelectedItem="@SelectedItemBoundChild" @bind-SelectedItems="@SelectedItemsBoundChild"
                          RowStyleFunc="SelectedRowStyleFunc" MultiSelection="MultiSelection" FixedHeader="true" FixedFooter="true" Height="@CalculateHeight(context.Value?.Count ?? 0, true)"
                          RowsPerPage="RowsPerPage" Class="m-0 p-0" Elevation="0" Striped="false" Bordered="false" Hover="true" Outlined="true" Dense="true" Breakpoint="Breakpoint.None">
                    <HeaderContent>
                        @foreach (var cfg in Configs)
                        {
                            <MudTh Style="border: thin solid darkgray; padding: 2px 10px 2px 10px;">
                                <MudTableSortLabel T="TTableType" Style="font-size: smaller" SortLabel="@cfg.Identifier.ToString()" SortBy="@ChooseSortingAlgorithm(cfg)">
                                    @cfg.DisplayName
                                </MudTableSortLabel>
                            </MudTh>
                        }
                    </HeaderContent>

                    <RowTemplate Context="rowData">
                        @foreach (var cfg in Configs)
                        {
                            <MudTd @key="@(cfg.Identifier.ToString() + rowData.GetHashCode())" Style="font-size: smaller; padding: 10px" DataLabel="@cfg.DisplayName">@FormatOutput(cfg, rowData)</MudTd>
                        }
                    </RowTemplate>
                    <PagerContent>
                        @if (context.Value.Count > RowsPerPage)
                        {
                            <MudTablePager PageSizeOptions="PageSizeOptions" />
                        }
                    </PagerContent>
                </MudTable>
            }
        </ChildRowContent>

        <PagerContent>
            @if (GroupedData.Count > RowsPerPage)
            {
                <MudTablePager PageSizeOptions="PageSizeOptions" />
            }
        </PagerContent>
    </MudTable>
}
else
{
    <MudTable Items="FilterDataSource(Data)" T="TTableType" @bind-SelectedItem="@SelectedItemBoundChild" @bind-SelectedItems="@SelectedItemsBoundChild"
              RowStyleFunc="SelectedRowStyleFunc" MultiSelection="MultiSelection" FixedHeader="FixedHeader" Height="@CalculateHeight()"
              RowsPerPage="@RowsPerPage" Class="m-0 p-0" Elevation="0" Bordered="false" Striped="true"
              Hover="true" Outlined="false" Dense="true" Breakpoint="Breakpoint.None">
        <HeaderContent>
            @foreach (var cfg in Configs)
            {
                <MudTh Style="padding: 10px;">
                    <MudTableSortLabel T="TTableType" Style="font-size: smaller" SortLabel="@cfg.Identifier.ToString()" SortBy="@(ChooseSortingAlgorithm(cfg))">
                        @cfg.DisplayName
                    </MudTableSortLabel>
                </MudTh>
            }
        </HeaderContent>

        <RowTemplate>
            @foreach (var cfg in Configs)
            {
                <MudTd @key="@(cfg.Identifier.ToString()+context.GetHashCode())" Style="font-size: smaller; padding: 10px" DataLabel="@cfg.DisplayName">@(FormatOutput(cfg, context))</MudTd>
            }
        </RowTemplate>

        <PagerContent>
            @if (Data?.Count > RowsPerPage)
            {
                <MudTablePager PageSizeOptions="PageSizeOptions" />
            }
        </PagerContent>
    </MudTable>
}

<MudToolBar>
</MudToolBar>

@code
{
    [Parameter]
    public bool FixedHeader { get; set; }

    [Parameter]
    public bool FixedFooter { get; set; }

    [Parameter]
    public int MaxTableHeight { get; set; }

    [Parameter]
    public int RowsPerPage { get; set; } = 50;

    [Parameter]
    public int[] PageSizeOptions { get; set; } = { 10, 25, 50, 100, 250 };

    [Parameter]
    public List<TTableType> Data { get; set; }

    [Parameter]
    public TTableType SelectedItem { get; set; }

    [Parameter]
    public EventCallback<TTableType> SelectedItemChanged { get; set; }

    private TTableType SelectedItemBoundChild
    {
        get => SelectedItem;
        set => SelectedItemChanged.InvokeAsync(value);
    }

    [Parameter]
    public bool MultiSelection { get; set; }

    [Parameter]
    public HashSet<TTableType> SelectedItems { get; set; }

    [Parameter]
    public EventCallback<HashSet<TTableType>> SelectedItemsChanged { get; set; }

    private HashSet<TTableType> SelectedItemsBoundChild
    {
        get => SelectedItems;
        set => SelectedItemsChanged.InvokeAsync(value);
    }

    [Parameter]
    public List<ColumnConfig<TTableType>> Configs { get; set; }

    private ColumnConfig<TTableType> SelectedGroupable { get; set; }

    private string _selectedGroupId;
    private bool _groupingEnabled;
    private bool _filteringEnabled;
    private bool _editingEnabled;

    private IEnumerable<TTableType> _filteredData = new List<TTableType>();
    private SortedDictionary<string, List<TTableType>> GroupedData { get; set; } = new(new WordAndNumberStringComparer());
    private KeyValuePair<string, List<TTableType>> SelectedGroup { get; set; }

    private Dictionary<ColumnConfig<TTableType>, Delegate> _validators = new();
    private readonly HashSet<ColumnConfig<TTableType>> _comparables = new();
    private readonly HashSet<ColumnConfig<TTableType>> _groupables = new();
    private IEnumerable<IFilter<TTableType>> _filters = new List<IFilter<TTableType>>();

    protected override void OnInitialized()
    {
        base.OnInitialized();
        AssignColumnsByProperties();
        EnableAvailableFunctionality();
    }

    protected override void OnParametersSet()
    {
        base.OnParametersSet();
        CreateGroupsBasedOn(SelectedGroupable);
    }

    private void EnableAvailableFunctionality()
    {
        _groupingEnabled = Configs?.Any(c => c.IsGroupable) ?? false;
        _filteringEnabled = Configs?.Any(c => c.IsFilterable) ?? false;
        _editingEnabled = Configs?.Any(c => c.IsEditable) ?? false;
    }

    private void AssignColumnsByProperties()
    {
        foreach (var config in Configs)
        {
            if (CanBeCompared(config))
                _comparables.Add(config);

            if (config.IsGroupable)
                _groupables.Add(config);
        }
    }

    private static bool CanBeCompared(ColumnConfig<TTableType> config)
    {
        var interfaces = config.PropertyType.GetInterfaces();
        return interfaces.Any(i => i == typeof(IComparable) || i == typeof(IComparable<>).MakeGenericType(config.PropertyType));
    }

    private void CreateGroupsBasedOn(ColumnConfig<TTableType> selectedColumn)
    {
        SelectedGroupable = selectedColumn;

        if (selectedColumn is null || Data is null || Data.Count <= 1)
        {
            GroupedData.Clear();
            return;
        }

        foreach (var group in GroupedData.Values)
        {
            group.Clear();
        }

        // Must be done without deleting groups collections.
        // Otherwise will cause sub-table to scroll up after row click or edit.
        foreach (var item in FilterDataSource(Data))
        {

            string key = selectedColumn.GetValueFrom(item)?.ToString() ?? "No value";
            if (GroupedData.TryGetValue(key, out var collection))
                collection.Add(item);
            else
                GroupedData.Add(key, new List<TTableType> { item });
        }

        var emptyKeys = GroupedData.Where(d => d.Value.Count == 0)
            .Select(d => d.Key)
            .ToList();
        emptyKeys.ForEach(k => GroupedData.Remove(k));
    }

    private static dynamic FormatOutput(ColumnConfig<TTableType> config, TTableType context)
    {
        var value = config.GetValueFrom(context);

        if (config.Converter is not null)
            return config.Converter.SetFunc(value);

        if (config.DisplayFormatter is not null)
            return config.DisplayFormatter(value);

        if (value is DateTime or DateTimeOffset)
        {
            return config.FieldType switch
            {
                FieldType.AutoDetect => value,
                FieldType.Date => value.ToString(CultureInfo.CurrentCulture.DateTimeFormat.ShortDatePattern),
                FieldType.Time => value.ToString("t", CultureInfo.CurrentCulture),
                FieldType.DateAndTime => value.ToString("G", CultureInfo.CurrentCulture),
                FieldType.PlainText => value.ToString(),
                _ => throw new ArgumentOutOfRangeException($"Unknown value of {nameof(FieldType)} was used.")
            };
        }

        return value ?? string.Empty;
    }

    private void OnGroupClick(TableRowClickEventArgs<KeyValuePair<string, List<TTableType>>> args)
    {
        _selectedGroupId = _selectedGroupId == args.Item.Key ? null : args.Item.Key;
    }

    public async Task OpenEditItemDialog()
    {
        var dialog = _dialogService.Show<EditDialog<TTableType>>("Edit item",
            new DialogParameters
            {
                ["Configs"] = Configs,
                ["SourceItem"] = SelectedItem
            },
            Globals.Gui.DefaultDialogOptions);

        var result = await dialog.Result;
        if (result.Cancelled)
            return;
        var data = (TTableType)result.Data;
        await EditItem(data);
    }

    private Task EditItem(TTableType editedItem)
    {
        var oldItemIndex = Data.FindIndex(tt => tt.Equals(SelectedItem));
        if (oldItemIndex == -1)
            return Task.CompletedTask;
        Data[oldItemIndex] = editedItem;
        return SelectedItemChanged.InvokeAsync(editedItem);
    }

    public async Task OpenFilterItemDialog()
    {
        var dialog = _dialogService.Show<FilterDialog<TTableType>>("Filter by...",
            new DialogParameters
            {
                ["Configs"] = Configs
            },
            Globals.Gui.DefaultDialogOptions);

        var result = await dialog.Result;
        if (result.Cancelled)
            return;
        _filters = (IEnumerable<IFilter<TTableType>>)result.Data;
    }

    private IEnumerable<TTableType> FilterDataSource(IEnumerable<TTableType> data)
    {
        return _filters.IsNullOrEmpty()
            ? data
            : data.Filter(_filters);
    }

    private Func<TTableType, dynamic> ChooseSortingAlgorithm(ColumnConfig<TTableType> config)
    {
        return _comparables.Contains(config)
            ? new Func<TTableType, dynamic>(config.GetValueFrom)
            : item => config.GetValueFrom(item)?.ToString();
    }

    private string CalculateHeight(int rows = 0, bool isNested = false)
    {
        // No height set
        if (MaxTableHeight < 1)
            return null;

        // non-nested table is either unlimited or always set to given MaxHeight
        if (isNested is false)
            return MaxTableHeight < 1 ? null : MaxTableHeight + "px";

        // rows in group * row height + header height and some
        var theoreticalSize = (rows * 38) + 120;

        // 70% for nested table, so user can grab below nested table and drag to other groupings
        return (theoreticalSize > MaxTableHeight * 0.7 ? MaxTableHeight * 0.7 : theoreticalSize) + "px";
    }

    private string SelectedRowStyleFunc(TTableType rowValue, int rowNumber)
    {
        return MultiSelection switch
        {
            true  => SelectedItems?.Contains(rowValue) ?? false,
            false => SelectedItem?.Equals(rowValue) ?? false

        } ? Globals.Gui.SelectedTableRowStyle : string.Empty;
    }
}