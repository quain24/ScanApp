@using System.Globalization
@using ScanApp.Common.Helpers
@using ScanApp.Components.Common.Table.Dialogs
@using ScanApp.Components.Common.Table.Enums
@using ScanApp.Components.Common.Table.Utilities
@using SharedExtensions
@using System
@inject IDialogService _dialogService
@typeparam TTableType

@if (GroupedData?.Count > 0)
{
    <MudTable Items="GroupedData" T="KeyValuePair<string, List<TTableType>>" OnRowClick="OnGroupClick"
              FixedHeader="FixedHeader" FixedFooter="FixedFooter" Height="@CalculateHeight()" RowsPerPage="RowsPerPage"
              Class="m-0 p-0" Elevation="0" Bordered="false" Striped="true" Hover="true" Outlined="false" Dense="true" Breakpoint="Breakpoint.None">
        <ToolBarContent>
            @if (Configs?.Count > 0 && _groupables.Count > 0)
            {
                <TableToolbar T="TTableType" Groupables="_groupables" SelectedGroupableChanged="@(s => CreateGroupsBasedOn(s))" SelectedGroupable="SelectedGroupable"
                              OnEditClick="@OpenEditItemDialog" OnFilterClick="@OpenFilterItemDialog" EditVisible="@_editingEnabled" EditDisabled="@(SelectedItem is null && SelectedItems.IsNullOrEmpty())"
                              FilterVisible="@_filteringEnabled" GroupingVisible="@_groupingEnabled" FiltersApplied="@(_filters?.Any() ?? false)"
                              OnRemoveFilterClick="RemoveFilters"></TableToolbar>
            }
        </ToolBarContent>

        <HeaderContent>
            <MudTh Style="@GroupedHeaderStyle">
                Grouped by: @SelectedGroupable.DisplayName
            </MudTh>
        </HeaderContent>

        <RowTemplate>
            <MudTd DataLabel="@context.Key">@context.Key</MudTd>
        </RowTemplate>
        <ChildRowContent>
            @if (_selectedGroupId == context.Key)
            {
                <MudTable Items="@FilterDataSource(context.Value)" T="TTableType" @bind-SelectedItem="@SelectedItemBoundChild" @bind-SelectedItems="@SelectedItemsBoundChild"
                          RowStyleFunc="RowStyleFunc" MultiSelection="MultiSelection" FixedHeader="true" FixedFooter="true" Height="@CalculateHeight(context.Value?.Count ?? 0, true)"
                          RowsPerPage="RowsPerPage" Class="m-0 p-0" Elevation="0" Striped="false" Bordered="false" Hover="true" Outlined="true" Dense="true" Breakpoint="Breakpoint.None">

                    <ColGroup>
                        @ColumnStyles
                    </ColGroup>

                    <HeaderContent>
                        @foreach (var cfg in Configs)
                        {
                            <MudTh Style="@GroupHeaderStyle">
                                <MudTableSortLabel T="TTableType" Style="font-size: smaller" SortLabel="@cfg.Identifier.ToString()" SortBy="@ChooseSortingAlgorithm(cfg)">
                                    @cfg.DisplayName
                                </MudTableSortLabel>
                            </MudTh>
                        }
                    </HeaderContent>

                    <RowTemplate Context="rowData">
                        @foreach (var cfg in Configs)
                        {
                            <MudTd @key="@(cfg.Identifier.ToString() + rowData.GetHashCode())" Style="@RowStyle" DataLabel="@cfg.DisplayName">@FormatOutput(cfg, rowData)</MudTd>
                        }
                    </RowTemplate>
                    <PagerContent>
                        @if (context.Value.Count > RowsPerPage)
                        {
                            <MudTablePager PageSizeOptions="PageSizeOptions" />
                        }
                    </PagerContent>
                </MudTable>
            }
        </ChildRowContent>

        <PagerContent>
            @if (GroupedData.Count > RowsPerPage)
            {
                <MudTablePager PageSizeOptions="PageSizeOptions" />
            }
        </PagerContent>
    </MudTable>
}
else
{
    <MudTable Items="FilterDataSource(Data)" T="TTableType" @bind-SelectedItem="@SelectedItemBoundChild" @bind-SelectedItems="@SelectedItemsBoundChild"
              RowStyleFunc="RowStyleFunc" MultiSelection="MultiSelection" FixedHeader="FixedHeader" Height="@CalculateHeight()" OnRowClick="@(async args => await OnRowClick(args))"
              RowsPerPage="@RowsPerPage" Class="m-0 p-0" Elevation="0" Bordered="false" Striped="true"
              Hover="true" Outlined="false" Dense="true" Breakpoint="Breakpoint.None">

        <ToolBarContent>
            @if (Configs?.Count > 0 && _groupables.Count > 0)
            {
                <TableToolbar T="TTableType" Groupables="_groupables" SelectedGroupableChanged="@(s => CreateGroupsBasedOn(s))" SelectedGroupable="SelectedGroupable"
                              OnAddClick="@OpenAddItemDialog" AddVisible="_addingEnabled" AddDisabled="false"
                              OnEditClick="@OpenEditItemDialog" OnFilterClick="@OpenFilterItemDialog" EditVisible="@_editingEnabled" EditDisabled="@(SelectedItem is null && SelectedItems.IsNullOrEmpty())"
                              FilterVisible="@_filteringEnabled" GroupingVisible="@_groupingEnabled" FiltersApplied="@(_filters?.Any() ?? false)"
                              OnRemoveFilterClick="RemoveFilters"></TableToolbar>
            }
        </ToolBarContent>

        <ColGroup>
            @ColumnStyles
        </ColGroup>

        <HeaderContent>
            @foreach (var cfg in Configs)
            {
                <MudTh Style="@HeaderStyle">
                    <MudTableSortLabel T="TTableType" Style="font-size: smaller" SortLabel="@cfg.Identifier.ToString()" SortBy="@(ChooseSortingAlgorithm(cfg))">
                        @cfg.DisplayName
                    </MudTableSortLabel>
                </MudTh>
            }
        </HeaderContent>

        <RowTemplate>
            @foreach (var cfg in Configs)
            {
                <MudTd @key="@(cfg.Identifier.ToString() + context.GetHashCode())" Style="@RowStyle" DataLabel="@cfg.DisplayName">@(FormatOutput(cfg, context))</MudTd>
            }
        </RowTemplate>

        <PagerContent>
            @if (Data?.Count > RowsPerPage)
            {
                <MudTablePager PageSizeOptions="PageSizeOptions" />
            }
        </PagerContent>
    </MudTable>
}

@code
{

    /// <inheritdoc cref="MudTableBase.FixedHeader" />
    [Parameter] public bool FixedHeader { get; set; }

    /// <inheritdoc cref="MudTableBase.FixedFooter" />
    [Parameter] public bool FixedFooter { get; set; }

    /// <inheritdoc cref="MudTableBase.Height" />
    [Parameter] public int MaxTableHeight { get; set; }

    ///<summary>
    /// Gets or sets number of rows per single table page.<br />
    /// If the table has more items than this number, it will break into pages of said size.
    /// </summary>
    /// <value>Number of rows per single page. If set to 0, table will disable pagination. Default value is <c>50</c></value>
    [Parameter] public int RowsPerPage { get; set; } = 50;

    ///<summary>
    /// Gets or sets available page size options for user to choose from.
    /// </summary>
    /// <value>Array of page sizes. Default values are 10, 25, 50, 100 and 250 rows per page.</value>
    [Parameter] public int[] PageSizeOptions { get; set; } = { 10, 25, 50, 100, 250 };

    /// <summary>
    /// Gets or sets default row behavior for OnClick event. If enabled, clicking the row will open edit dialog.
    /// </summary>
    /// <value><see langword="true" /> if clicking a row will open edit dialog, otherwise <see langword="false" />.</value>
    [Parameter] public bool EditOnRowClick { get; set; }

    /// <summary>
    /// <inheritdoc cref="MudComponentBase.Style" />.<br />
    /// This parameter restyles table header, when table is in non-grouped mode..
    /// </summary>
    /// <value>A <see cref="string" /> representing CSS style if set. By default <c>"padding: 10px"</c>.</value>
    [Parameter] public string HeaderStyle { get; set; } = "padding: 10px";

    /// <summary>
    /// <inheritdoc cref="MudComponentBase.Style" />.<br />
    /// This parameter restyles header of table when it is in grouped mode.
    /// </summary>
    /// <value>A <see cref="string" /> representing CSS style if set. By default <c>"padding: 10px; z-index: 10"</c>.</value>
    [Parameter] public string GroupedHeaderStyle { get; set; } = "padding: 10px; z-index: 10";

    /// <summary>
    /// <inheritdoc cref="MudComponentBase.Style" />.<br />
    /// This parameter restyles headers of sub-tables when main table is in grouped mode.
    /// </summary>
    /// <value>A <see cref="string" /> representing CSS style if set. By default <c>"border: thin solid darkgray; padding: 2px 10px 2px 10px;"</c>.</value>
    [Parameter] public string GroupHeaderStyle { get; set; } = "border: thin solid darkgray; padding: 2px 10px 2px 10px;";

    /// <summary>
    /// Gets or sets custom CSS for table rows<br />
    /// Note that some of the CSS settings are override by table settings.
    /// </summary>
    /// <value>A <see cref="string" /> representing CSS style if set. By default <c>"font-size: smaller; padding: 10px"</c>.</value>
    [Parameter] public string RowStyle { get; set; } = "font-size: smaller; padding: 10px";

    /// <summary>
    /// Gets or sets data to be displayed in table. One item will be displayed as one row.
    /// </summary>
    [Parameter] public List<TTableType> Data { get; set; }

    ///<summary>
    ///<inheritdoc cref="MudTable{T}.SelectedItem" />
    /// <br />@Bind-... notation is supported
    /// </summary>
    [Parameter] public TTableType SelectedItem { get; set; }

    ///<summary>
    ///<inheritdoc cref="MudTable{T}.SelectedItemChanged" />
    /// <br />@Bind-... notation is supported
    /// </summary>
    [Parameter] public EventCallback<TTableType> SelectedItemChanged { get; set; }

    private TTableType SelectedItemBoundChild
    {
        get => SelectedItem;
        set => SelectedItemChanged.InvokeAsync(value);
    }

    ///<inheritdoc cref="MudTableBase.MultiSelection" />
    [Parameter] public bool MultiSelection { get; set; }

    ///<summary>
    ///<inheritdoc cref="MudTable{T}.SelectedItems" />
    /// <br />@Bind-... notation is supported
    /// </summary>
    [Parameter] public HashSet<TTableType> SelectedItems { get; set; }

    /// <summary>
    ///<inheritdoc cref="MudTable{T}.SelectedItemsChanged" />
    /// <br />@Bind-... notation is supported
    /// </summary>
    [Parameter] public EventCallback<HashSet<TTableType>> SelectedItemsChanged { get; set; }

    private HashSet<TTableType> SelectedItemsBoundChild
    {
        get => SelectedItems;
        set
        {
            SelectedItems = value;
            SelectedItemsChanged.InvokeAsync(value);
        }
    }

    /// <summary>
    /// Gets or sets collection of configuration objects used to set all properties and behaviors of corresponding columns in table.
    /// </summary>
    /// <value>Collection of configuration objects.</value>
    [Parameter] public List<ColumnConfig<TTableType>> Configs { get; set; }

    /// <summary>
    /// Gets or sets visibility of edit button.
    /// </summary>
    /// <value>
    /// <list type="bullet">
    /// <item>
    ///     <term><see cref="Show.Auto" /></term>
    ///     <description>Table will decide if edit button is needed (<strong>default</strong>).</description>
    /// </item>
    /// <item>
    ///     <term><see cref="Show.Yes" /></term>
    ///     <description>Always show edit button.</description>
    /// </item>
    /// <item>
    ///     <term><see cref="Show.No" /></term>
    ///     <description>Never show edit button.</description>
    /// </item>
    /// </list>
    /// </value>
    [Parameter] public Show ShowEditButton { get; set; } = Show.Auto;

    /// <summary>
    /// Gets or sets visibility of filter button.
    /// </summary>
    /// <value>
    /// <list type="bullet">
    /// <item>
    ///     <term><see cref="Show.Auto" /></term>
    ///     <description>Table will decide if filter button is needed (<strong>default</strong>).</description>
    /// </item>
    /// <item>
    ///     <term><see cref="Show.Yes" /></term>
    ///     <description>Always show filter button.</description>
    /// </item>
    /// <item>
    ///     <term><see cref="Show.No" /></term>
    ///     <description>Never show filter button.</description>
    /// </item>
    /// </list>
    /// </value>
    [Parameter] public Show ShowFilterButton { get; set; } = Show.Auto;

    /// <summary>
    /// Gets or sets visibility of Add button.
    /// </summary>
    /// <value>
    /// <list type="bullet">
    /// <item>
    ///     <term><see cref="Show.Auto" /></term>
    ///     <description>Table will decide if Add button is needed (<strong>default</strong>).</description>
    /// </item>
    /// <item>
    ///     <term><see cref="Show.Yes" /></term>
    ///     <description>Always show Add button.</description>
    /// </item>
    /// <item>
    ///     <term><see cref="Show.No" /></term>
    ///     <description>Never show Add button.</description>
    /// </item>
    /// </list>
    /// </value>
    [Parameter] public Show ShowAddButton { get; set; } = Show.Auto;

    /// <summary>
    /// Gets or sets visibility of group-by field.
    /// </summary>
    /// <value>
    /// <list type="bullet">
    /// <item>
    ///     <term><see cref="Show.Auto" /></term>
    ///     <description>Table will decide if group-by field is needed (<strong>default</strong>).</description>
    /// </item>
    /// <item>
    ///     <term><see cref="Show.Yes" /></term>
    ///     <description>Always show group-by field.</description>
    /// </item>
    /// <item>
    ///     <term><see cref="Show.No" /></term>
    ///     <description>Never show group-by field.</description>
    /// </item>
    /// </list>
    /// </value>
    [Parameter] public Show ShowGroupsField { get; set; } = Show.Auto;

    /// <summary>
    /// Gets or sets how the edit dialog fields will be visible when dialog is opened.
    /// </summary>
    /// <value>If set to <see langword="true" />, dialog will start with all fields expanded (<strong>default</strong>).</value>
    [Parameter] public bool EditDialogStartsExpanded { get; set; } = true;

    /// <summary>
    /// Gets or sets how the filter dialog fields will be visible when dialog is opened.
    /// </summary>
    /// <value>If set to <see langword="true" />, dialog will start with all fields expanded.</value>
    [Parameter] public bool FilterDialogStartsExpanded { get; set; }

    /// <summary>
    /// Gets or sets how the edit dialog fields that are marked by validation as invalid will be visible when dialog is opened.
    /// </summary>
    /// <value>If set to <see langword="true" />, dialog will start with all invalid fields expanded (<strong>default</strong>).</value>
    [Parameter] public bool EditDialogInvalidFieldsStartExpanded { get; set; } = true;

    /// <inheritdoc cref="MudTable{T}.RowStyleFunc" />
    /// <remarks>If not set, will be used to mark currently selected row(s) by default.</remarks>
    /// <value>A <see cref="Func{TTableType, int, string}" /> delegate used to restyle rows if set, otherwise default built-in delegate.</value>
    [Parameter] public Func<TTableType, int, string> RowStyleFunc { get; set; }

    /// <summary>
    /// Gets or sets <typeparam name="TTableType" /> object factory necessary for creating new table items for when 'Add' is enabled.<br />
    /// Supported delegates are:
    /// <list type="bullet">
    /// <item>
    /// <term><see cref="Func{TTableType, TTableType}">Func&lt;TTableType&gt;</see></term>
    /// <description>Parameter-less delegate creating new <typeparamref name="TTableType" />.</description>
    /// </item>
    /// <item>
    /// <term><see cref="Func{TTableType, TTableType}">Func&lt;TTableType, TTableType&gt;</see></term>
    /// <description>Delegate taking as a parameter currently selected item, creating new <typeparamref name="TTableType" />.</description>
    /// </item>
    /// <item>
    /// <term><see cref="Func{HashSet{TTableType}, TTableType}">Func&lt;HashSet&lt;TTableType&gt;, TTableType&gt;</see></term>
    /// <description>Delegate taking as a parameter currently selected items, creating new <typeparamref name="TTableType" />.</description>
    /// </item>
    /// <item>
    /// <term><see cref="Func{IEnumerable{TTableType}, TTableType}">Func&lt;IEnumerable&lt;TTableType&gt;, TTableType&gt;</see></term>
    /// <description>Delegate taking as a parameter this tables data-set (<see cref="Data" />),<br />
    /// creating new <typeparamref name="TTableType" />.</description>
    /// </item>
    /// </list>
    /// </summary>
    [Parameter] public object ItemFactory { get; set; }

    private ColumnConfig<TTableType> SelectedGroupable { get; set; }

    private string _selectedGroupId;
    private bool _groupingEnabled;
    private bool _filteringEnabled;
    private bool _editingEnabled;
    private bool _addingEnabled;
    private SortedDictionary<string, List<TTableType>> GroupedData { get; set; } = new(new WordAndNumberStringComparer());
    private KeyValuePair<string, List<TTableType>> SelectedGroup { get; set; }
    private readonly HashSet<ColumnConfig<TTableType>> _comparables = new();
    private readonly HashSet<ColumnConfig<TTableType>> _groupables = new();
    private readonly List<IFilter<TTableType>> _filters = new();
    private MarkupString ColumnStyles { get; set; }

    protected override void OnInitialized()
    {
        base.OnInitialized();
        AssignColumnsByProperties();
        EnableAvailableFunctionality();
        ColumnStyles = new ColumnStyleBuilder<TTableType>(Configs).Build();
        RowStyleFunc ??= SelectedRowStyleFunc;
    }

    protected override void OnParametersSet()
    {
        base.OnParametersSet();
        CreateGroupsBasedOn(SelectedGroupable);
    }

    private void AssignColumnsByProperties()
    {
        foreach (var config in Configs)
        {
            if (CanBeComparedDirectly(config))
                _comparables.Add(config);

            if (config.IsGroupable)
                _groupables.Add(config);
        }
    }

    private void EnableAvailableFunctionality()
    {
        _filteringEnabled = (Configs?.Any(c => c.IsFilterable) ?? false)
                            && (ShowFilterButton is Show.Auto) || ShowFilterButton is Show.Yes;
        _groupingEnabled = (Configs?.Any(c => c.IsGroupable) ?? false)
                           && (ShowGroupsField is Show.Auto) || ShowGroupsField is Show.Yes;
        _editingEnabled = (Configs?.Any(c => c.IsEditable) ?? false)
                          && (ShowEditButton is Show.Auto) || ShowEditButton is Show.Yes;
        _addingEnabled = (ItemFactory is not null && ShowAddButton is Show.Auto) || ShowAddButton is Show.Yes;
    }

    private static bool CanBeComparedDirectly(ColumnConfig<TTableType> config)
    {
        var interfaces = config.PropertyType.GetInterfaces();
        return interfaces.Any(i => i == typeof(IComparable) || i == typeof(IComparable<>).MakeGenericType(config.PropertyType));
    }

    private void CreateGroupsBasedOn(ColumnConfig<TTableType> selectedColumn)
    {
        SelectedGroupable = selectedColumn;

        if (selectedColumn is null || Data is null || Data.Count <= 1)
        {
            GroupedData.Clear();
            return;
        }

        // Must be done without deleting groups collections.
        // Otherwise will cause sub-table to scroll up after row click or edit.
        foreach (var group in GroupedData.Values)
        {
            group.Clear();
        }

        foreach (var item in FilterDataSource(Data))
        {

            string key = selectedColumn.GetValueFrom(item)?.ToString() ?? "No value";
            if (GroupedData.TryGetValue(key, out var collection))
                collection.Add(item);
            else
                GroupedData.Add(key, new List<TTableType> { item });
        }

        var emptyKeys = GroupedData.Where(d => d.Value.Count == 0)
            .Select(d => d.Key)
            .ToList();
        emptyKeys.ForEach(k => GroupedData.Remove(k));
    }

    private IEnumerable<TTableType> FilterDataSource(IEnumerable<TTableType> data)
    {
        return _filters.Count == 0
            ? data
            : data.Filter(_filters);
    }

    private static dynamic FormatOutput(ColumnConfig<TTableType> config, TTableType context)
    {
        var value = config.GetValueFrom(context);

        if (config.Converter is not null)
            return config.Converter.SetFunc(value);

        if (value is DateTime or DateTimeOffset)
        {
            return config.FieldType switch
            {
                FieldType.AutoDetect => value,
                FieldType.Date => value.ToString(CultureInfo.CurrentCulture.DateTimeFormat.ShortDatePattern),
                FieldType.Time => value.ToString("t", CultureInfo.CurrentCulture),
                FieldType.DateAndTime => value.ToString("G", CultureInfo.CurrentCulture),
                FieldType.PlainText => value.ToString(),
                _ => throw new ArgumentOutOfRangeException($"Unknown value of {nameof(FieldType)} was used.")
            };
        }

        return value ?? string.Empty;
    }

    private void OnGroupClick(TableRowClickEventArgs<KeyValuePair<string, List<TTableType>>> args)
    {
        _selectedGroupId = _selectedGroupId == args.Item.Key ? null : args.Item.Key;
    }

    private async Task OnRowClick(TableRowClickEventArgs<TTableType> args)
    {
        if (EditOnRowClick)
        {
            SelectedItem = args.Item;
            await OpenEditItemDialog();
        }
    }

    /// <summary>
    /// Opens editing dialog which context is currently selected item.
    /// </summary>
    /// <returns>Awaitable task.</returns>
    public async Task OpenEditItemDialog()
    {
        var dialog = _dialogService.Show<EditDialog<TTableType>>("Edit item",
            new DialogParameters
            {
                ["Configs"] = Configs,
                ["SourceItem"] = SelectedItem,
                ["StartExpanded"] = EditDialogStartsExpanded,
                ["ExpandInvalidPanelsOnStart"] = EditDialogInvalidFieldsStartExpanded
            },
            Globals.Gui.DefaultDialogOptions);

        var result = await dialog.Result;
        if (result.Cancelled)
            return;
        var data = (TTableType)result.Data;
        await EditItem(data);
    }

    private Task EditItem(TTableType editedItem)
    {
        var oldItemIndex = Data.FindIndex(tt => tt.Equals(SelectedItem));
        if (oldItemIndex == -1)
            return Task.CompletedTask;
        Data[oldItemIndex] = editedItem;
        return SelectedItemChanged.InvokeAsync(editedItem);
    }

    /// <summary>
    /// Opens table filtering dialog.
    /// </summary>
    /// <returns>Awaitable task.</returns>
    public async Task OpenFilterItemDialog()
    {
        var dialog = _dialogService.Show<FilterDialog<TTableType>>("Filter by...",
            new DialogParameters
            {
                ["Configs"] = Configs,
                ["StartExpanded"] = FilterDialogStartsExpanded
            },
            Globals.Gui.DefaultDialogOptions);

        var result = await dialog.Result;
        if (result.Cancelled)
            return;
        _filters.AddRange(result.Data as IEnumerable<IFilter<TTableType>> ?? Enumerable.Empty<IFilter<TTableType>>());
        CreateGroupsBasedOn(SelectedGroupable);
    }

    /// <summary>
    /// Clears applied content filters.
    /// </summary>
    public void RemoveFilters()
    {
        _filters.Clear();
        CreateGroupsBasedOn(SelectedGroupable);
    }

    public async Task OpenAddItemDialog()
    {
        var dialog = _dialogService.Show<AddDialog<TTableType>>("Add new item",
            new DialogParameters
            {
                ["Configs"] = Configs,
                ["SourceItem"] = CreateNewItem()
            },
            Globals.Gui.DefaultDialogOptions);

        var result = await dialog.Result;
        if (result.Cancelled)
            return;

        if(result.Data is TTableType item)
            Data.Add(item);
        CreateGroupsBasedOn(SelectedGroupable);
    }

    private TTableType CreateNewItem()
    {
        try
        {
            return ItemFactory switch
            {
                Func<TTableType> factory => factory.Invoke(),
                Func<TTableType, TTableType> factory => factory.Invoke(SelectedItem),
                Func<IEnumerable<TTableType>, TTableType> factory => factory.Invoke(Data),
                Func<HashSet<TTableType>, TTableType> factory => factory.Invoke(SelectedItems),
                null => throw new ArgumentNullException(nameof(ItemFactory), "No factory delegate was provided"),
                _ => throw new ArgumentOutOfRangeException(nameof(ItemFactory), "Provided factory type is not compatible with allowed delegate types.")
            };
        }
        catch (Exception ex)
        {
            throw new Exception($"Something went wrong when trying to create new item using provided {nameof(ItemFactory)}: {ex.Message}", ex);
        }
    }

    private Func<TTableType, dynamic> ChooseSortingAlgorithm(ColumnConfig<TTableType> config)
    {
        return _comparables.Contains(config)
            ? new Func<TTableType, dynamic>(config.GetValueFrom)
            : item => config.GetValueFrom(item)?.ToString();
    }

    private string CalculateHeight(int rows = 0, bool isNested = false)
    {
        // No height set
        if (MaxTableHeight < 1)
            return null;

        // non-nested table is either unlimited or always set to given MaxHeight
        if (isNested is false)
            return MaxTableHeight < 1 ? null : MaxTableHeight + "px";

        // rows in group * row height + header height and some
        var theoreticalSize = (rows * 38) + 120;

        // 70% for nested table, so user can grab below nested table and drag to other groupings
        return (theoreticalSize > MaxTableHeight * 0.7 ? MaxTableHeight * 0.7 : theoreticalSize) + "px";
    }

    private string SelectedRowStyleFunc(TTableType rowValue, int rowNumber)
    {
        return MultiSelection switch
        {
            true => SelectedItems?.Contains(rowValue) ?? false,
            false => SelectedItem?.Equals(rowValue) ?? false

        } ? Globals.Gui.SelectedTableRowStyle : string.Empty;
    }
}