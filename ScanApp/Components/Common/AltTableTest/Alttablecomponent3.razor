@using ScanApp.Components.Common.ScanAppTable.Options
@using ScanApp.Common.Extensions
@using System.Globalization
@using ScanApp.Common.Helpers
@inject IDialogService _dialogService
@typeparam TTableType

@if (Configs?.Count > 0 && _groupables.Count > 0)
{
    <MudSelect FullWidth="false" SelectedValuesChanged="items => CreateGroupsFrom(items.First())" T="ColumnConfig<TTableType>" Label="Groups" @bind-Value="_selectedGroupable" ToStringFunc="@(t => t is null ? string.Empty : t.PropertyName)">
        <MudSelectItem T="ColumnConfig<TTableType>" Value="null">None</MudSelectItem>
        @foreach (var cc in _groupables)
        {
            <MudSelectItem Value="cc">@cc.DisplayName</MudSelectItem>
        }
    </MudSelect>
}


@if (GroupedData?.Count > 0)
{
    <MudTable FixedHeader="FixedHeader" @bind-SelectedItem="@SelectedGroup" OnRowClick="OnClick" T="KeyValuePair<string, List<TTableType>>" Height="@(CalculateHeight(GroupedData.Count))" RowsPerPage="RowsPerPage" Class="m-0 p-0" Elevation="0" Bordered="false" Striped="true" Hover="true" Outlined="false" Items="GroupedData" Dense="true" Breakpoint="Breakpoint.None">
        <HeaderContent>
            <MudTh Style="padding: 10px; z-index: 100">
                Grouped by: @_selectedGroupable.DisplayName
            </MudTh>
        </HeaderContent>

        <RowTemplate>
            <MudTd DataLabel="@context.Key">@context.Key</MudTd>
        </RowTemplate>
        <ChildRowContent>
            @if (_clicked == context.Key)
            {
                <MudTable Context="display" T="TTableType" FixedHeader="FixedHeader" Height="@(CalculateHeight(context.Value.Count))" RowsPerPage="RowsPerPage" Class="m-0 p-0" Elevation="0" Bordered="false" Striped="true" Hover="true" Outlined="false" Items="context.Value" SelectedItem="@SelectedItem" SelectedItemChanged="@SingleSelectedItemHasChanged" Dense="true" Breakpoint="Breakpoint.None">
                    <HeaderContent>
                        @foreach (var cfg in Configs)
                        {
                            <MudTh Style="border: thin solid darkgray; padding: 2px 10px 2px 10px;">
                                <MudTableSortLabel T="TTableType" Style="font-size: smaller" SortLabel="@cfg.Identifier.ToString()" SortBy="@(ChooseSortingAlgorithm(cfg))">
                                    @cfg.DisplayName
                                </MudTableSortLabel>
                            </MudTh>
                        }
                    </HeaderContent>

                    <RowTemplate Context="rowData">
                        @foreach (var cfg in Configs)
                        {
                            <MudTd @key="@(cfg.Identifier.ToString() + rowData.GetHashCode())" Style="font-size: smaller; padding: 10px" DataLabel="@cfg.DisplayName">@(FormatOutput(cfg, rowData))</MudTd>
                        }
                    </RowTemplate>
                    <PagerContent>
                        @if (context.Value.Count > RowsPerPage)
                        {
                            <MudTablePager PageSizeOptions="PageSizeOptions" />
                        }
                    </PagerContent>
                </MudTable>
            }
        </ChildRowContent>

        <PagerContent>
            @if (GroupedData.Count > RowsPerPage)
            {
                <MudTablePager PageSizeOptions="PageSizeOptions" />
            }
        </PagerContent>
    </MudTable>
}
else
{
    <MudTable FixedHeader="FixedHeader" Height="@(MaxTableHeight > 0 ? MaxTableHeight + "px" : string.Empty)" RowsPerPage="@RowsPerPage" T="TTableType" Class="m-0 p-0" Elevation="0" Bordered="false" Striped="true" Hover="true" Outlined="false" Items="Data" SelectedItem="@SelectedItem" SelectedItemChanged="@SingleSelectedItemHasChanged" Dense="true" Breakpoint="Breakpoint.None">
        <HeaderContent>
            @foreach (var cfg in Configs)
            {
                <MudTh Style="padding: 10px;">
                    <MudTableSortLabel T="TTableType" Style="font-size: smaller" SortLabel="@cfg.Identifier.ToString()" SortBy="@(ChooseSortingAlgorithm(cfg))">
                        @cfg.DisplayName
                    </MudTableSortLabel>
                </MudTh>
            }
        </HeaderContent>

        <RowTemplate>
            @foreach (var cfg in Configs)
            {
                <MudTd @key="@(cfg.Identifier.ToString()+context.GetHashCode())" Style="font-size: smaller; padding: 10px" DataLabel="@cfg.DisplayName">@(FormatOutput(cfg, context))</MudTd>
            }
        </RowTemplate>
        <FooterContent>
            <MudTFootRow>
                <MudTd colspan="5">
                    Selected:
                    @if (SelectedItem is not null)
                    {
                        @foreach (var cfg in Configs)
                        {
                            @(FormatOutput(cfg, SelectedItem).ToString() + ' ')
                        }
                    }
                </MudTd>
            </MudTFootRow>
        </FooterContent>
        <PagerContent>
            @if (Data?.Count > RowsPerPage)
            {
                <MudTablePager PageSizeOptions="PageSizeOptions" />
            }
        </PagerContent>
    </MudTable>
}



@code
{
    private void OnClick(TableRowClickEventArgs<KeyValuePair<string, List<TTableType>>> args)
    {
        _clicked = _clicked == args.Item.Key ? null : args.Item.Key;
    }

    string _clicked;
    [Parameter]
    public bool FixedHeader { get; set; }

    [Parameter]
    public int MaxTableHeight { get; set; }

    [Parameter]
    public int RowsPerPage { get; set; } = 2000;

    [Parameter]
    public int[] PageSizeOptions { get; set; } = { 10, 25, 50, 100, 250 };

    [Parameter]
    public List<TTableType> Data { get; set; }

    [Parameter]
    public EventCallback<List<TTableType>> DataChanged { get; set; }

    [Parameter]
    public TTableType SelectedItem { get; set; }

    [Parameter]
    public EventCallback<TTableType> SelectedItemChanged { get; set; }

    [Parameter]
    public List<ColumnConfig<TTableType>> Configs { get; set; }

    private SortedDictionary<string, List<TTableType>> GroupedData { get; set; } = new(new WordAndNumberStringComparer());
    private KeyValuePair<string, List<TTableType>> SelectedGroup { get; set; }

    private Dictionary<ColumnConfig<TTableType>, Delegate> _validators = new();
    private Dictionary<ColumnConfig<TTableType>, RenderFragment> _columns = new();
    private readonly HashSet<ColumnConfig<TTableType>> _comparables = new();
    private readonly HashSet<ColumnConfig<TTableType>> _groupables = new();
    private ColumnConfig<TTableType> _selectedGroupable;

    protected override void OnInitialized()
    {
        AssignColumnsByProperties();
        base.OnInitialized();
    }

    protected override void OnParametersSet()
    {
        CreateGroupsFrom(_selectedGroupable);
        base.OnParametersSet();
    }

    private void AssignColumnsByProperties()
    {
        foreach (var config in Configs)
        {
            if (CanBeCompared(config))
                _comparables.Add(config);

            if (config.IsGroupable)
                _groupables.Add(config);
        }
    }

    private static bool CanBeCompared(ColumnConfig<TTableType> config)
    {
        var interfaces = config.PropertyType.GetInterfaces();
        return interfaces.Any(i => i == typeof(IComparable) || i == typeof(IComparable<>).MakeGenericType(config.PropertyType));
    }

    private void CreateGroupsFrom(ColumnConfig<TTableType> selectedColumn)
    {
        GroupedData.Clear();

        if (selectedColumn is null || Data is null || Data.Count <= 1)
            return;

        foreach (var item in Data)
        {
            string key = selectedColumn.GetValueFrom(item)?.ToString() ?? "No value";
            if (GroupedData.TryGetValue(key, out var collection))
                collection.Add(item);
            else
                GroupedData.Add(key, new List<TTableType> { item });
        }
    }

    private static dynamic FormatOutput(ColumnConfig<TTableType> config, TTableType context)
    {
        var value = config.GetValueFrom(context);

        if (config.DisplayFormatter is not null)
            return config.DisplayFormatter(value);

        if (value is DateTime or DateTimeOffset)
        {
            return config.FieldType switch
            {
                FieldType.AutoDetect => value,
                FieldType.Date => value.ToString(CultureInfo.CurrentCulture.DateTimeFormat.ShortDatePattern),
                FieldType.Time => value.ToString("t", CultureInfo.CurrentCulture),
                FieldType.DateAndTime => value.ToString("G", CultureInfo.CurrentCulture),
                FieldType.PlainText => value.ToString(),
                _ => throw new ArgumentOutOfRangeException($"Unknown value of {nameof(FieldType)} was used.")
            };
        }

        return value ?? string.Empty;
    }

    public async Task OpenEditItemDialog()
    {
        var dialog = _dialogService.Show<EditDialog<TTableType>>("Sorting dialog",
            new DialogParameters
            {
                ["Configs"] = Configs,
                ["SourceItem"] = SelectedItem
            },
            Globals.Gui.DefaultDialogOptions);

        var result = await dialog.Result;
        if (result.Cancelled)
            return;
        var data = (TTableType)result.Data;
        await EditItem(data);
    }

    private Task EditItem(TTableType editedItem)
    {
        var oldItemIndex = Data.FindIndex(tt => tt.Equals(SelectedItem));
        if (oldItemIndex == -1)
            return Task.CompletedTask;
        Data[oldItemIndex] = editedItem;
        SelectedItem = editedItem;
        return Task.WhenAll(DataChanged.InvokeAsync(Data), SelectedItemChanged.InvokeAsync(SelectedItem));
    }

    public Task DeleteItem(TTableType element)
    {
        Data.Remove(element);
        return Task.WhenAll(DataChanged.InvokeAsync(Data), SelectedItemChanged.InvokeAsync(default));
    }

    private void SingleSelectedItemHasChanged(TTableType newItem)
    {
        SelectedItem = newItem;
        SelectedItemChanged.InvokeAsync(newItem);
    }

    private Func<TTableType, dynamic> ChooseSortingAlgorithm(ColumnConfig<TTableType> config)
    {
        return _comparables.Contains(config)
            ? new Func<TTableType, dynamic>(config.GetValueFrom)
            : item => config.GetValueFrom(item)?.ToString();
    }

    private string CalculateHeight(int rows)
    {
        if (MaxTableHeight < 1)
            return string.Empty;
        // rows * row height + header height and some
        var theoreticalSize = (rows * 38) + 200;
        return theoreticalSize > MaxTableHeight
            ? MaxTableHeight + "px"
            : theoreticalSize + "px";
    }


}