@using ScanApp.Components.Common.ScanAppTable.Options
@using ScanApp.Services
@using Microsoft.AspNetCore.Components.Rendering
@using System.Linq.Expressions
@typeparam TTableType

@if (GroupedData.Any())
{
    <MudTabs Class="m-0 p-0" Elevation="2" Outlined="false" Position="Position.Top" Rounded="true" Border="false" ApplyEffectsToContainer="false">
        @foreach (var group in GroupedData)
        {
            <MudTabPanel Text="@group.Key">
                <MudTable Class="table-condensed m-0 p-0" Elevation="0" Bordered="false" Striped="true" Outlined="false" Items="group.Value" SelectedItem="@SelectedItem" SelectedItemChanged="@SelectedItemChanged" Dense="true" Breakpoint="Breakpoint.None">
                    <HeaderContent>
                        @foreach (var cfg in Configs)
                        {
                            <MudTh Style="padding: 10px;">
                                <MudTableSortLabel T="TTableType" Style="font-size: small" SortLabel="@cfg.Identifier.ToString()" SortBy="@(ChooseSortingAlgorithm(cfg))">
                                    @cfg.DisplayName
                                </MudTableSortLabel>
                            </MudTh>
                        }
                    </HeaderContent>

                    <RowTemplate>
                        @foreach (var cfg in Configs)
                                {
                            <MudTd Style="font-size: small; padding: 10px" DataLabel="@cfg.DisplayName">@((object) PropertyPath<TTableType>.GetValue(cfg, context) ?? string.Empty)</MudTd>
                                }
                    </RowTemplate>
                </MudTable>
            </MudTabPanel>
        }
    </MudTabs>
}
@if (_selectedGrouping is null)
{
    <MudTable Class="table-condensed m-0 p-0" Elevation="0" Bordered="false" Striped="true" Outlined="false" Items="Data" SelectedItem="@SelectedItem" SelectedItemChanged="@SelectedItemChanged" Dense="true" Breakpoint="Breakpoint.None">
        <HeaderContent>
            @foreach (var cfg in Configs)
            {
                <MudTh Style="padding: 10px;">
                    <MudTableSortLabel T="TTableType" Style="font-size: small" SortLabel="@cfg.Identifier.ToString()" SortBy="@(ChooseSortingAlgorithm(cfg))">
                        @cfg.DisplayName
                    </MudTableSortLabel>
                </MudTh>
            }
        </HeaderContent>

        <RowTemplate>
            @foreach (var cfg in Configs)
                {
                <MudTd DataLabel="@cfg.DisplayName" Style="font-size: small; padding: 10px">@(PropertyPath<TTableType>.GetValue(cfg, context) ?? string.Empty)</MudTd>
                }
        </RowTemplate>
    </MudTable>
}
@if (Configs?.Count > 0 && Data?.Count > 0 && SelectedItem is not null)
{
    <MudForm @ref="_form" @bind-IsValid="@_success" Class="table-condensed m-0 p-0">
        @foreach (var col in _columns)
        {
            @col.Value
        }
    </MudForm>
    <MudButton Disabled="@(!_success)">Validation ok</MudButton>
    <MudButton OnClick="@(_ => DeleteItem(SelectedItem))">Delete</MudButton>

    <MudSelect FullWidth="false" SelectedValuesChanged="items => CreateGroupsFrom(items.First())" T="ColumnConfig<TTableType>" Label="Groups" @bind-Value="_selectedGrouping" ToStringFunc="@(t => t is null ? string.Empty : t.PropertyName)">
        <MudSelectItem T="ColumnConfig<TTableType>" Value="null">None</MudSelectItem>
        @foreach (var cc in _groupables)
        {
            <MudSelectItem Value="cc">@cc.DisplayName</MudSelectItem>
        }
    </MudSelect>
}

@code
{
    [Parameter]
    public List<TTableType> Data { get; set; }

    [Parameter]
    public EventCallback<List<TTableType>> DataChanged { get; set; }

    [Parameter]
    public TTableType SelectedItem { get; set; } = new();

    [Parameter]
    public EventCallback<TTableType> SelectedItemChanged { get; set; }

    [Parameter]
    public List<ColumnConfig<TTableType>> Configs { get; init; }

    private Dictionary<ColumnConfig<TTableType>, Delegate> _validators = new();
    private Dictionary<ColumnConfig<TTableType>, RenderFragment> _columns = new();
    private HashSet<ColumnConfig<TTableType>> _comparables = new();
    private HashSet<ColumnConfig<TTableType>> _groupables = new();

    private Dictionary<string, List<TTableType>> GroupedData { get; set; } = new();

    private MudForm _form;
    private bool _success;
    private ColumnConfig<TTableType> _selectedGrouping;

    private Dictionary<string, List<TTableType>> CreateGroupsFrom(ColumnConfig<TTableType> selectedColumn)
    {
        if (selectedColumn is null)
            return GroupedData = new Dictionary<string, List<TTableType>>();

        var groupedData = new Dictionary<string, List<TTableType>>();

        foreach (var item in Data)
        {
            string key = PropertyPath<TTableType>.GetValue(selectedColumn, item).ToString() ?? string.Empty;
            if (groupedData.TryGetValue(key, out var collection))
                collection.Add(item);
            else
                groupedData.Add(key, new List<TTableType> { item });
        }
        return GroupedData = groupedData
            .OrderBy(x => x.Key, StringComparer.OrdinalIgnoreCase)
            .ToDictionary(x => x.Key, x => x.Value);
    }

    protected override void OnInitialized()
    {
        CacheValidators();
        CacheColumnRenderFragments();
        AssignColumnsByProperties();
    }

    private void CacheValidators()
    {
        foreach (var config in Configs)
        {
            var methodType = config.GetType().GetMethod(nameof(config.Validate))?.MakeGenericMethod(config.PropertyType)
                             ?? throw new ArgumentException("Method for validator func creation is not accessible / not existing" +
                                                            " - check source class of this method.");
            var validatorFuncType = Expression.GetDelegateType(config.PropertyType, typeof(IEnumerable<string>));
            var validationDelegate = Delegate.CreateDelegate(validatorFuncType, config, methodType);

            _validators.Add(config, validationDelegate);
        }
    }

    private void CacheColumnRenderFragments()
    {
        foreach (var config in Configs)
        {
            var column = CreateEditFields(config);
            _columns.Add(config, column);
        }
    }

    RenderFragment CreateEditFields(ColumnConfig<TTableType> config)
    {
        return builder =>
        {
            if (config.PropertyType == typeof(DateTime?))
                CreateDateFields(builder, config);
            else
            {
            // Type of mud blazor text field (int, string, etc)
            var textFieldType = typeof(MudTextField<>).MakeGenericType(config.PropertyType);

            // Start creating text field
            builder.OpenComponent(0, textFieldType);
                builder.AddAttribute(1, "Value", (object)PropertyPath<TTableType>.GetValue(config, SelectedItem));

            // Set callback for edit action
            var callbackType = typeof(EventCallback<>).MakeGenericType(config.PropertyType);
                Action<dynamic> editDelegate = obj => EditProperty(obj, config.Identifier);
                dynamic callback = Activator.CreateInstance(callbackType, this, editDelegate);
                builder.AddAttribute(2, "ValueChanged", callback);
                builder.AddAttribute(3, "Validation", _validators[config]);
                builder.AddAttribute(4, "Immediate", true);
                builder.AddAttribute(5, "Disabled", !config.IsEditable);
                builder.CloseComponent();
            }
        };
    }

    void CreateDateFields(RenderTreeBuilder builder, ColumnConfig<TTableType> config)
    {
        var type = typeof(MudDatePicker);
        builder.OpenComponent(10, type);
        builder.AddAttribute(11, "Date", PropertyPath<TTableType>.GetValue(config, SelectedItem) as DateTime?);
        var callbackType = typeof(EventCallback<>).MakeGenericType(typeof(DateTime?));
        Action<DateTime?> editDelegate = obj => DateChanged(obj, config);
        dynamic callback = Activator.CreateInstance(callbackType, this, editDelegate);
        builder.AddAttribute(12, "DateChanged", callback);
        builder.AddAttribute(13, "Validation", _validators[config]);
        builder.AddAttribute(14, "Disabled", !config.IsEditable);
        builder.CloseComponent();
    }

    private void DateChanged(DateTime? date, ColumnConfig<TTableType> config)
    {
        PropertyPath<TTableType>.SetValue(config, SelectedItem, date);
    }

    private void AssignColumnsByProperties()
    {
        foreach (var config in Configs)
        {
            if (CanBeCompared(config))
                _comparables.Add(config);

            if (config.IsGroupable)
                _groupables.Add(config);
        }
    }

    private bool CanBeCompared(ColumnConfig<TTableType> config)
    {
        var interfaces = config.PropertyType.GetInterfaces();
        return interfaces.Any(i => i == typeof(IComparable) || i == typeof(IComparable<>).MakeGenericType(config.PropertyType));
    }

    private Func<TTableType, object> ChooseSortingAlgorithm(ColumnConfig<TTableType> config)
    {
        return _comparables.Contains(config)
            ? new Func<TTableType, object>(item => PropertyPath<TTableType>.GetValue(config, item))
            : item => PropertyPath<TTableType>.GetValue(config, item).ToString();
    }

    private void EditProperty(dynamic o, Guid guid)
    {
        PropertyPath<TTableType>.SetValue(Configs.First(c => c.Identifier == guid), SelectedItem, o);
    }

    private async Task DeleteItem(TTableType element)
    {
        Data.Remove(element);
        RemoveFromGrouping(element);

        await DataChanged.InvokeAsync(Data);
        await SelectedItemChanged.InvokeAsync(SelectedItem = null);
    }

    private void RemoveFromGrouping(TTableType element)
    {
        if (GroupedData.Count == 0)
            return;

        dynamic emptyGroup = null;
        foreach (var kvp in GroupedData)
        {
            if (kvp.Value.Remove(element))
                emptyGroup = kvp.Key;
        }
        GroupedData.Remove(emptyGroup);
    }

    //RenderFragment CreateHeaders(ColumnConfig<TTableType> config) => builder =>
    //{
    //    if (_comparables.Contains(config))
    //    {
    //        builder.OpenComponent<MudTh>(100);
    //        builder.AddAttribute(101, "ChildContent", (RenderFragment)(builder2 =>
    //        {
    //            builder2.OpenComponent(200, typeof(MudTableSortLabel<>).MakeGenericType(typeof(TTableType)));
    ////builder2.AddAttribute(201);

    //            builder2.AddAttribute(202, "ChildContent", (RenderFragment)(builder3 =>
    //            {
    //                builder3.AddContent(300, config.DisplayName);
    //            }));

    //            builder2.AddContent(13, Services.PropertyPath<TTableType>.GetValue(config, new TTableType()));
    //        }));

    //        builder.OpenComponent(101, typeof(MudTableSortLabel<>).MakeGenericType(typeof(TTableType)));
    //        builder.AddAttribute(12, "ChildContent", (RenderFragment)(builder3 =>
    //        {
    //            builder3.AddContent(13, Services.PropertyPath<TTableType>.GetValue(config, new TTableType()));
    //        }));
    //    }

    //    builder.OpenComponent(10, typeof(MudTd));
    //    builder.AddAttribute(11, "DataLabel", config.DisplayName);
    //    builder.AddAttribute(12, "ChildContent", (RenderFragment)(builder3 =>
    //    {
    //        builder3.AddContent(13, Services.PropertyPath<TTableType>.GetValue(config, new TTableType()));
    //    }));

    //    builder.CloseComponent();
    //};
}