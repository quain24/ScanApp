@using ScanApp.Components.Common.ScanAppTable.Options
@using ScanApp.Common.Extensions
@using System.Globalization
@using Microsoft.AspNetCore.Components.Web.Virtualization
@inject IDialogService _dialogService
@typeparam TTableType

@if (GroupedData?.Count > 0)
{
    <MudExpansionPanels Style="font-size: small" MultiExpansion="true" Dense="true" DisableGutters="true">
        <Virtualize Items="@GroupedData" OverscanCount="5" ItemSize="55">
            <MudExpansionPanel @key="@(context.Key)" Text="@context.Key.Truncate()">
                <MudTable RowsPerPage="RowsPerPage" T="TTableType" Class="m-0 p-0" Elevation="0" Bordered="false" Striped="true" Hover="true" Outlined="false" Items="context.Value" SelectedItem="@SelectedItem" SelectedItemChanged="@SingleSelectedItemHasChanged" Dense="true" Breakpoint="Breakpoint.None">
                    <HeaderContent>
                        @foreach (var cfg in Configs)
                        {
                            <MudTh Style="padding: 10px;">
                                <MudTableSortLabel T="TTableType" Style="font-size: smaller" SortLabel="@cfg.Identifier.ToString()" SortBy="@(ChooseSortingAlgorithm(cfg))">
                                    @cfg.DisplayName
                                </MudTableSortLabel>
                            </MudTh>
                        }
                    </HeaderContent>

                    <RowTemplate Context="rowData">
                        @foreach (var cfg in Configs)
                        {
                            <MudTd @key="@(cfg.Identifier.ToString()+rowData.GetHashCode())" Style="font-size: smaller; padding: 10px" DataLabel="@cfg.DisplayName">@(FormatOutput(cfg, rowData))</MudTd>
                        }
                    </RowTemplate>
                    <PagerContent>
                        @if (context.Value.Count > RowsPerPage)
                        {
                            <MudTablePager PageSizeOptions="new[] {10, 50, 100, 1000}"/>
                        }
                    </PagerContent>
                </MudTable>
            </MudExpansionPanel>
        </Virtualize>
    </MudExpansionPanels>
}
else
{
    <MudTable RowsPerPage="@RowsPerPage" T="TTableType" Class="m-0 p-0" Elevation="0" Bordered="false" Striped="true" Hover="true" Outlined="false" Items="Data" SelectedItem="@SelectedItem" SelectedItemChanged="@SingleSelectedItemHasChanged" Dense="true" Breakpoint="Breakpoint.None">
        <HeaderContent>
            @foreach (var cfg in Configs)
            {
                <MudTh Style="padding: 10px;">
                    <MudTableSortLabel T="TTableType" Style="font-size: smaller" SortLabel="@cfg.Identifier.ToString()" SortBy="@(ChooseSortingAlgorithm(cfg))">
                        @cfg.DisplayName
                    </MudTableSortLabel>
                </MudTh>
            }
        </HeaderContent>

        <RowTemplate>
            @foreach (var cfg in Configs)
            {
                <MudTd @key="@(cfg.Identifier.ToString()+context.GetHashCode())" Style="font-size: smaller; padding: 10px" DataLabel="@cfg.DisplayName">@(FormatOutput(cfg, context))</MudTd>
            }
        </RowTemplate>
        <FooterContent>
            <MudTFootRow>
                <MudTd colspan="5">
                    Selected:
                    @if (SelectedItem is not null)
                    {
                        @foreach (var cfg in Configs)
                        {
                            @(FormatOutput(cfg, SelectedItem).ToString() + ' ')
                        }
                    }
                </MudTd>
            </MudTFootRow>
        </FooterContent>
        <PagerContent>
            @if (Data?.Count > RowsPerPage)
            {
                <MudTablePager PageSizeOptions="new[] {10, 50, 100, 1000}"/>
            }
        </PagerContent>
        
    </MudTable>
}

@if (Configs?.Count > 0 && _groupables.Count > 0)
{
    <MudSelect FullWidth="false" SelectedValuesChanged="items => CreateGroupsFrom(items.First())" T="ColumnConfig<TTableType>" Label="Groups" @bind-Value="_selectedGroupable" ToStringFunc="@(t => t is null ? string.Empty : t.PropertyName)">
        <MudSelectItem T="ColumnConfig<TTableType>" Value="null">None</MudSelectItem>
        @foreach (var cc in _groupables)
        {
            <MudSelectItem Value="cc">@cc.DisplayName</MudSelectItem>
        }
    </MudSelect>
}

@code
{
    [Parameter]
    public int RowsPerPage { get; set; } = 50;

    [Parameter]
    public List<TTableType> Data { get; set; }

    [Parameter]
    public EventCallback<List<TTableType>> DataChanged { get; set; }

    [Parameter]
    public TTableType SelectedItem { get; set; }

    [Parameter]
    public EventCallback<TTableType> SelectedItemChanged { get; set; }

    [Parameter]
    public List<ColumnConfig<TTableType>> Configs { get; set; }

    private Dictionary<string, List<TTableType>> GroupedData { get; set; } = new(StringComparer.OrdinalIgnoreCase);

    private Dictionary<ColumnConfig<TTableType>, Delegate> _validators = new();
    private Dictionary<ColumnConfig<TTableType>, RenderFragment> _columns = new();
    private HashSet<ColumnConfig<TTableType>> _comparables = new();
    private HashSet<ColumnConfig<TTableType>> _groupables = new();
    private ColumnConfig<TTableType> _selectedGroupable;

    private dynamic FormatOutput(ColumnConfig<TTableType> config, TTableType context)
    {
        var value = config.GetValueFrom(context);

        if (config.DisplayFormatter is not null)
            return config.DisplayFormatter(value?.ToString() ?? string.Empty);

        if (value is DateTime or DateTimeOffset)
        {
            switch (config.FieldType)
            {
                case FieldEditType.AutoDetect:
                    return value;
                case FieldEditType.Date:
                    return value.ToString(CultureInfo.CurrentCulture.DateTimeFormat.ShortDatePattern);
                case FieldEditType.Time:
                    return value.ToString("t", CultureInfo.CurrentCulture);
                case FieldEditType.DateAndTime:
                    return value.ToString("G", CultureInfo.CurrentCulture);
            }
        }

        return value ?? string.Empty;
    }

    public async Task OpenEditItemDialog()
    {
        var dialog = _dialogService.Show<EditDialog<TTableType>>("Sorting dialog",
            new DialogParameters
            {
                ["Configs"] = Configs,
                ["SourceItem"] = SelectedItem
            },
            Globals.Gui.DefaultDialogOptions);

        var result = await dialog.Result;
        if (result.Cancelled)
            return;
        var data = (TTableType)result.Data;
        await EditItem(data);
    }

    private Task EditItem(TTableType editedItem)
    {
        var oldItemIndex = Data.FindIndex(tt => tt.Equals(SelectedItem));
        if (oldItemIndex == -1)
            return Task.CompletedTask;
        Data[oldItemIndex] = editedItem;
        SelectedItem = editedItem;
        return Task.WhenAll(DataChanged.InvokeAsync(Data), SelectedItemChanged.InvokeAsync(SelectedItem));
    }

    public Task DeleteItem(TTableType element)
    {
        Data.Remove(element);
        return Task.WhenAll(DataChanged.InvokeAsync(Data), SelectedItemChanged.InvokeAsync(default));
    }

    protected override void OnInitialized()
    {
        AssignColumnsByProperties();
        base.OnInitialized();
    }

    protected override void OnParametersSet()
    {
        CreateGroupsFrom(_selectedGroupable);
        Console.WriteLine("==================================");
        base.OnParametersSet();
    }

    private void AssignColumnsByProperties()
    {
        foreach (var config in Configs)
        {
            if (CanBeCompared(config))
                _comparables.Add(config);

            if (config.IsGroupable)
                _groupables.Add(config);
        }
    }

    private bool CanBeCompared(ColumnConfig<TTableType> config)
    {
        var interfaces = config.PropertyType.GetInterfaces();
        return interfaces.Any(i => i == typeof(IComparable) || i == typeof(IComparable<>).MakeGenericType(config.PropertyType));
    }

    private void CreateGroupsFrom(ColumnConfig<TTableType> selectedColumn)
    {
        GroupedData.Clear();

        if (selectedColumn is null || Data is null || Data.Count <= 1)
            return;

        foreach (var item in Data)
        {
            string key = selectedColumn.GetValueFrom(item)?.ToString() ?? "No value";
            if (GroupedData.TryGetValue(key, out var collection))
                collection.Add(item);
            else
                GroupedData.Add(key, new List<TTableType> { item });
        }
        GroupedData = GroupedData
            .OrderBy(x => x.Key, StringComparer.InvariantCultureIgnoreCase)
            .ToDictionary(x => x.Key, x => x.Value);
    }

    private void SingleSelectedItemHasChanged(TTableType newItem)
    {
        SelectedItem = newItem;
        SelectedItemChanged.InvokeAsync(newItem);
    }

    private Func<TTableType, object> ChooseSortingAlgorithm(ColumnConfig<TTableType> config)
    {
        return _comparables.Contains(config)
            ? new Func<TTableType, object>(config.GetValueFrom)
            : item => config.GetValueFrom(item)?.ToString();
    }

}