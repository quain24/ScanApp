@using ScanApp.Application.Common.Interfaces
@using ScanApp.Application.Common.Helpers.Result
@using ScanApp.Application.Admin.Commands.AddUserToRole
@using ScanApp.Application.Admin.Commands.RemoveUserFromRole
@using ScanApp.Application.Admin.Queries.GetUserRoles
@using ScanApp.Application.Admin.Queries.GetUserVersion
@using ScanApp.Store.Features.Admin
@using ScanApp.Store.Features.Admin.FillUserRoles
@using ScanApp.Store.Features.Admin.ReadRoleNames
@using Version = ScanApp.Domain.ValueObjects.Version
@inject IScopedMediator Mediator
@inject ISnackbar Snackbar
@inject IState<AdminState> State
@inject IDispatcher Dispatcher
@inject IActionSubscriber Subscriber

@inherits Fluxor.Blazor.Web.Components.FluxorComponent

<MudGrid>
    <MudItem xs="12" lg="6" Class="px-1">
        <MudTable RowStyleFunc="RowStyleFunc" Breakpoint="Breakpoint.None" T="string" Items="@State.Value.UserNames" SelectedItem="State.Value.SelectedUserName" RowsPerPage="5"
                  Filter="new Func<string, bool>(FilterUsers)" OnRowClick="@FillRolesData" Hover="true" Dense="true">
            <ToolBarContent>
                <MudText Typo="Typo.h6">Users</MudText>
                <MudToolBarSpacer />
                <MudTextField @bind-Value="_searchStringName" Placeholder="Search" Adornment="Adornment.End" AdornmentIcon="@Icons.Material.Filled.Search" IconSize="Size.Medium" Class="mt-0"></MudTextField>
            </ToolBarContent>
            <HeaderContent>
                <MudTh>Name</MudTh>
            </HeaderContent>
            <RowTemplate>
                <MudTd Style="height: 51px;">@context</MudTd>
            </RowTemplate>
            <PagerContent>
                <MudTablePager PageSizeOptions="new[] {5, 10, 20}" />
            </PagerContent>
        </MudTable>
    </MudItem>
    <MudItem xs="12" lg="6" Class="px-1">
        <MudTable Breakpoint="Breakpoint.None" Items="@_userRoles" @bind-SelectedItem="_selectedRole" RowsPerPage="5"
                  Filter="new Func<(string Name, bool IsInRole), bool>(FilterRoles)" Hover="true" Dense="true">
            <ToolBarContent>
                <MudText Typo="Typo.h6">Roles</MudText>
                <MudToolBarSpacer />
                <MudTextField @bind-Value="_searchStringRole" Placeholder="Search" Adornment="Adornment.End" AdornmentIcon="@Icons.Material.Filled.Search" IconSize="Size.Medium" Class="mt-0"></MudTextField>
            </ToolBarContent>
            <HeaderContent>
                <MudTh>Role</MudTh>
                <MudTh>Active</MudTh>
            </HeaderContent>
            <RowTemplate>
                <MudTd>@context.Name</MudTd>
                <MudTd><MudSwitch T="bool" CheckedChanged="@(async arg => await Switch(arg))" Checked="@context.IsInRole" Color="Color.Primary"></MudSwitch></MudTd>
            </RowTemplate>
            <PagerContent>
                <MudTablePager PageSizeOptions="new[] {5, 10, 20}" />
            </PagerContent>
        </MudTable>
    </MudItem>
</MudGrid>

@code {

    [Parameter]
    public string SelectedRowStyle { get; set; }

    private bool _disableEdit = true;
    private bool _disableSave = true;

    private List<(string Name, bool IsInRole)> _userRoles = new();
    private string _selectedUserName;
    private Version _selectedUserVersion = Version.Empty();
    private string _searchStringName;
    private string _lastCheckedUserName;
    private (string Name, bool IsInRole) _selectedRole;
    private string _searchStringRole;

    protected override void OnInitialized()
    {
        base.OnInitialized();
        Subscriber.SubscribeToAction<ReadRoleNamesSuccessAction>(this, action =>
        {
            _userRoles = State.Value.RoleNames.Select(r =>
            {
                var isActive = action.RoleNames.Contains(r, StringComparer.OrdinalIgnoreCase);
                return (r, isActive);
            }).ToList();
        });

        Subscriber.SubscribeToAction<FillUserRolesFailureAction>(this, action => DisplayError(action?.Error?.ErrorCode + " " + action?.Error?.ErrorText));
    }

    private bool FilterUsers(string name)
    {
        if (string.IsNullOrWhiteSpace(_searchStringName))
            return true;
        return name?.Contains(_searchStringName, StringComparison.OrdinalIgnoreCase) ?? false;
    }

    private bool FilterRoles((string Name, bool IsInRole) data)
    {
        if (string.IsNullOrWhiteSpace(_searchStringRole))
            return true;
        return data.Name?.Contains(_searchStringRole, StringComparison.OrdinalIgnoreCase) ?? false;
    }

    private async void FillRolesData(TableRowClickEventArgs<string> args)
    {
        if (args.Item.Equals(State.Value.SelectedUserName))
            return;

        Dispatcher.Dispatch(new FillUserRolesAction(args.Item));

    }

    private async Task Switch(bool arg)
    {
        Result<Version> result;
        string message;

        if (_selectedRole.IsInRole)
        {
            result = await Mediator.SendScoped(new RemoveUserFromRoleCommand(_selectedUserName, _selectedUserVersion, _selectedRole.Name));
            message = $"Role {_selectedRole.Name} removed from {_selectedUserName}";
        }
        else
        {
            result = await Mediator.SendScoped(new AddUserToRoleCommand(_selectedUserName, _selectedUserVersion, _selectedRole.Name));
            message = $"Role {_selectedRole.Name} added to {_selectedUserName}";
        }

        if (result.Conclusion is false)
        {
            DisplayError(string.IsNullOrEmpty(result.ErrorDescription?.ErrorMessage) ? result.ErrorDescription?.ErrorType.ToString() : result.ErrorDescription.ErrorMessage);
            return;
        }

        var index = _userRoles.FindIndex(u => u.Name.Equals(_selectedRole.Name, StringComparison.OrdinalIgnoreCase));
        _userRoles[index] = (_selectedRole.Name, !_selectedRole.IsInRole);
        _selectedUserVersion = result.Output;

        StateHasChanged();
        DisplaySuccess(message);
    }

    private void DisplayError(string errorMessage)
    {
        Snackbar.Add(errorMessage, Severity.Error, options =>
        {
            options.SnackbarVariant = Variant.Filled;
        });
    }

    private void DisplaySuccess(string message)
    {
        Snackbar.Add(message, Severity.Success, options =>
        {
            options.SnackbarVariant = Variant.Filled;
        });
    }

    private bool FilterRoles(string roleName)
    {
        if (string.IsNullOrWhiteSpace(_searchStringRole))
            return true;
        return roleName?.Contains(_searchStringRole, StringComparison.OrdinalIgnoreCase) ?? false;
    }

    private string RowStyleFunc(string rowValue, int rowNumber)
    {
        return rowValue.Equals(State.Value.SelectedUserName)
            ? SelectedRowStyle ?? string.Empty
            : string.Empty;
    }

    protected override void Dispose(bool disposing)
    {
        Subscriber.UnsubscribeFromAllActions(this);
        base.Dispose(disposing);
    }

}